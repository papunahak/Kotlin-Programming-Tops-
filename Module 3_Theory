Object Oriented Programming(OOPS):
The four principles of Object-Oriented Programming (OOP) in Kotlin are encapsulation, inheritance, polymorphism, and abstraction. 


Encapsulation 
Encapsulation involves bundling data (fields) and methods (functions) operating on the data into a single unit, typically a class. 
It also restricts direct access to an objectâ€™s data by using access modifiers such as private, protected, internal, and public.


Polymorphism
Polymorphism is the ability of an object to take on many forms. 
In Kotlin, polymorphism can be achieved through interfaces and abstract classes. 
Polymorphism allows objects of different types to be treated as instances of a standard base class. 


Abstraction
Abstraction is hiding the implementation from the user and giving some functionality. 

Inheritance 
Inheritance is one of the four fundamental principles of OOP.


Differences between abstract class and interface in Kotlin and provide
examples of when to use them?

Abstract Class
An abstract class serves as a blueprint for other classes. It can contain both abstract methods (methods without a body) and concrete methods (methods with implementation). It can also hold properties with backing fields (variables that store state). An abstract class cannot be instantiated directly.

Can have both abstract and non-abstract methods.
Can store state using val or var properties.
Can have a constructor.
A class can inherit only one abstract class (single inheritance).

Example:

abstract class Animal {
    abstract fun makeSound() 
    fun eat() {             
        println("This animal is eating")
    }
}

class Dog : Animal() {
    override fun makeSound() {
        println("Woof! Woof!")
    }
}

Interface
An interface is a contract that a class agrees to fulfill. It primarily defines abstract methods, though it can also provide default implementations. However, unlike abstract classes, interfaces cannot store state as they lack backing fields.
Methods in an interface are abstract by default (can include default implementations).
Properties in an interface are abstract by default (cannot store state).
Cannot have a constructor.
A class can implement multiple interfaces (multiple inheritance).

Example:
interface Movable {
    fun move() 

interface Flyable {
    fun fly() {
        println("Flying high!") 
    }
}

class Bird : Movable, Flyable {
    override fun move() {
        println("Bird is moving")
    }
}
